# todo🕊
1. 输入包的数量，流的数量，周期数，数据包之间的zipf分布系数，并且生成：./gen_zipf_input
2. 


# motivation
原先的packet_generate都是均匀的.均匀并不能描述真实网络流的运输情况.尽管后续将数据包的分布改为zipf,但是在对于描述真实网络流到达过程,却依然收效甚微

因此,选择不加以证明地使用zipf分布模拟数据包的到达流程,即:来自于不同流的数据包大量聚集在某一时刻

但是这样的做法可能依然存在问题:在真实的情况下应该是同一流的数据包大量聚集,而并非所有流的数据包都大量聚集在一块时间中

# 实现
采取敏捷开发方式,选择尽可能多地复用之前实现过的功能.

整体上来看,func分成这样几个部分

1. 输入包数,周期数,流的个数,数据包之间的zipf分布系数,各个流上的zipf分布系数 or 整体流的zipf分布系数
2. 假设每一个流都符合zipf分布,同时他们的zipf系数是相等的
3. 因此,真实的分布就变成了:
4. 先生成符合zipf分布的包-流 completed
4. 对于每一个流,固定一个时间戳
5. 对于每一个流,都是符合zipf分布的,它在一定时间之内被排空掉

# 语义说明
在gen_zipf_input里面,调用,在命令行先后输入包数量,流数量,时钟周期数,数据包分配的zipfa常数

# solution1
1. 输入包数,流数,周期数,每流数据包的zipf分布系数(这里的zipf从语义实现上来说只需要有一个),然后由zipf_input生成
2. 对于所有的流,确定一个随机的时间,比如说对于flow1,确定一个到达时间a
3. 如果说对于每一个流,在此时依然需要满足zipf分布,那么对于flow1,就有有效期[a,time]
4. 所以就只需要确定一个到达时间,然后让包在这个时间区间上面满足zipf分布

# solution2
> 随机地确定每个包的左边,根据包的数量反过来确定时间,从而确定包的右边.
> 那么也就是说,对于单个包的吞吐需要确定

对于s1和s2,都是需要n级别的空间,从而让第二个能够进入第一个

# solution final
1. 输入
2. 对于每一个流，标识一个这个流可用的空间
3. 对于每一个流,这个刚刚进入的时间满足正态分布
3. 让这个流可用的空间充满时间轴
4. 输出和时间轴对应的流
5. 根本跑不动 寄